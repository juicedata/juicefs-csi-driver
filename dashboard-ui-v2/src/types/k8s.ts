/**
 * Copyright 2024 Juicedata Inc
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { Quantity } from 'kubernetes-types/api/resource'
import { Job } from 'kubernetes-types/batch/v1'
import {
  Container,
  CSIVolumeSource,
  EnvVar,
  Lifecycle,
  Pod as NativePod,
  Node,
  PersistentVolume,
  PersistentVolumeClaim,
  PodSpec,
  Probe,
  ResourceRequirements,
  Volume,
  VolumeDevice,
  VolumeMount,
} from 'kubernetes-types/core/v1'
import { LabelSelector, ObjectMeta } from 'kubernetes-types/meta/v1'

export type Pod = {
  mountPods?: NativePod[]
  node?: Node
  pvcs?: PersistentVolumeClaim[]
  pvs?: PersistentVolume[]
  csiNode?: NativePod
} & NativePod

export type PV = PersistentVolume & {
  Pod: {
    namespace: string
    name: string
  }
}

export type PVC = PersistentVolumeClaim & {
  Pod: {
    namespace: string
    name: string
  }
}

export type PVCWithUniqueId = {
  PVC: PersistentVolumeClaim
  PV: PersistentVolume
  UniqueId: string
}

export type PVCWithPod = {
  PVC: PersistentVolumeClaim
  MountPods?: NativePod[]
}

export type PVCBasicInfo = {
  namespace: string
  name: string
  uid: string
}

export const accessModeMap: { [key: string]: string } = {
  ReadWriteOnce: 'RWO',
  ReadWriteMany: 'RWX',
  ReadOnlyMany: 'ROX',
  ReadWriteOncePod: 'RWOP',
}

export type PodToUpgrade = {
  node: string
  pods: NativePod[]
}

export type BatchConfig = {
  parallel: number
  ignoreError: boolean
  noRecreate: boolean
  node: string
  uniqueId: string
  batches: MountPodUpgrade[][]
  status: string
}

export type MountPodUpgrade = {
  name: string
  node: string
  csiNodePod: string
  status: string
}

export type PodDiffConfig = {
  pod: Pod
  oldSetting: Setting
  newSetting: Setting
}

export type OriginConfig = {
  enableNodeSelector?: boolean
  mountPodPatch?: OriginMountPodPatch[]
}

export type OriginMountPodPatch = {
  pvcSelector?: OriginPVCSelector
} & OriginMountPatch

export type OriginPVCSelector = {
  matchStorageClassName?: string
  matchName?: string
} & LabelSelector

export type OriginMountPatch = {
  ceMountImage?: string
  eeMountImage?: string
  cacheDirs?: MountPatchCacheDir[]
  labels?: { [name: string]: string }
  annotations?: { [name: string]: string }
  hostNetwork?: boolean
  hostPID?: boolean
  HostnameKey?: string
  livenessProbe?: Probe
  readinessProbe?: Probe
  startupProbe?: Probe
  lifecycle?: Lifecycle
  resources?: ResourceRequirements
  terminationGracePeriodSeconds?: number
  volumes?: Volume[]
  volumeDevices?: VolumeDevice[]
  volumeMounts?: VolumeMount[]
  env?: EnvVar[]
  InitContainers?: Container[]
  mountOptions?: string[]
}

export type MountPatchCacheDir = {
  type: string
  path?: string
  name?: string
  sizeLimit?: Quantity
  medium?: string
}

export type UpgradeJob = {
  job: Job
  config: BatchConfig
}

export type UpgradeJobWithDiff = {
  job: Job
  total: number
  config: BatchConfig
  diffs: [PodDiffConfig]
}

export type Setting = {
  UUID: string
  Name: string
  MetaUrl?: string
  Source: string
  Storage?: string
  FormatOptions?: string
  CachePVCs?: CachePVC[]
  CacheEmptyDir?: CacheEmptyDir
  CacheInlineVolumes?: CacheInlineVolume[]
  CacheDirs?: string[]

  // put in secret
  SecretKey?: string
  SecretKey2?: string
  Token?: string
  Passphrase?: string
  Envs?: { [name: string]: string }
  EncryptRsaKey?: string
  Configs?: { [name: string]: string }

  // put in volCtx
  DeletedDelay?: string
  CleanCache?: boolean
  HostPath?: string[]

  // mount
  UniqueId?: string // mount pod name is generated by uniqueId
  MountPath?: string // mountPath of mount pod or process mount
  Options?: string[] // mount options
  FormatCmd?: string // format or auth

  Attr?: OriginMountPatch
}

export type CachePVC = {
  PVCName: string
  Path: string
}

export type CacheEmptyDir = {
  Medium: string
  SizeLimit: Quantity
  Path: string
}

export type CacheInlineVolume = {
  CSI: CSIVolumeSource
  Path: string
}

export type CacheGroupTemplate = Omit<PodSpec, 'metadata' | 'containers'> &
  Omit<Container, 'name'> & {
    opts?: string[]
  }

export type CacheGroup = {
  metadata?: ObjectMeta
  spec: {
    updateStrategy: {
      type: 'RollingUpdate' | 'OnDelete'
      rollingUpdate: {
        maxUnavailable: number
      }
    }
    secretRef: {
      name: string
    }
    worker: {
      template: CacheGroupTemplate
      overwrite: (CacheGroupTemplate & { nodes: string[] })[]
    }
  }
  status?: {
    phase: string
    readyWorker?: number
    expectWorker?: number
    readyStr?: string
    cacheGroup?: string
  }
}
